% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fs_ext.R
\name{fs_ext}
\alias{fs_ext}
\alias{print.fs_ext}
\alias{as_fs_ext}
\alias{as_fs_ext.default}
\alias{as_fs_ext.fs_path}
\title{filename/path extension object}
\usage{
fs_ext(x = NULL)

\method{print}{fs_ext}(x, ...)

as_fs_ext(x, ...)

\method{as_fs_ext}{default}(x, ...)

\method{as_fs_ext}{fs_path}(x, exts = getOption("fs.exts"))
}
\arguments{
\item{x}{object; values to be converted to character. Character values
should omitting the leading \code{.} (period)}

\item{exts}{character allowable extensions}
}
\value{
a \code{\link[=fs_ext]{fs_ext()}} object.
}
\description{
A filename extension object allowing for extensions
containing \code{.}
}
\details{
\code{\link[=fs_ext]{fs_ext()}} provides a object for handling file/path extensions. This is
a character vector with a subclass \code{ext} that allows methods to be written
for it.

\code{as_fs_ext} returns the extension of its argument \code{x}.

If \code{x} is a
If \code{x} is a \emph{fs_path} object and \code{exts} is provided, x will identify
extensions will match these extensions first. This allows for extensions
with more than one \code{.} in the filename. Otherwise, \code{\link[fs:path_ext]{fs::path_ext()}} is used
and the extension is the character following the last \code{.} in the path or
filename.

Missing extensions are encoded as an empty string (\code{""}).
}
\examples{
  fs_ext( qw(one, two, three) )

  file <- "my_file.sql.rds"
  as_fs_ext(file)

  file <- file \%>\% fs::path()
  as_fs_ext(file)
  as_fs_ext(file, c('sql', 'rds', 'sql.rds'))

}
\seealso{
\itemize{
\item \code{\link[=ext]{ext()}}
\item \code{\link[fs:path_ext]{fs::path_ext()}}
}
}
